import CropCalendar from '../models/CropCalendar.js';
import FarmingPlan from '../models/FarmingPlan.js';
import ActivityConflict from '../models/ActivityConflict.js';

/**
 * Activity Planning Service
 * Generates auto-activity plans from crop calendar data
 * Validates scheduling and prevents conflicts
 */
class ActivityPlanningService {
  
  /**
   * Generate activity plan for a farming plan
   * @param {Object} plan - FarmingPlan document
   * @param {String} season - Current season
   * @returns {Array} - Generated activities
   */
  async generateActivityPlan(plan, season = 'all') {
    try {
      const cropName = plan.cropName.toLowerCase().trim();
      
      // Fetch crop calendar from database (NOT hardcoded)
      const calendar = await CropCalendar.findOne({
        cropName: cropName,
        isActive: true,
        $or: [
          { seasons: season },
          { seasons: 'all' }
        ]
      });
      
      if (!calendar) {
        console.warn(`No crop calendar found for ${cropName}`);
        return [];
      }
      
      const startDate = new Date(plan.startDate);
      const generatedActivities = [];
      
      // Generate activities from calendar template
      for (const template of calendar.activities) {
        // Handle recurring activities
        const occurrences = template.recurringCount || 1;
        const frequencyDays = this.getFrequencyInDays(template.recurringFrequency);
        
        for (let i = 0; i < occurrences; i++) {
          const scheduledDate = new Date(startDate);
          scheduledDate.setDate(scheduledDate.getDate() + template.daysFromStart + (i * frequencyDays));
          
          const activity = {
            activityType: template.activityType,
            description: template.reasonEnglish,
            descriptionTamil: template.reasonTamil,
            scheduledDate: scheduledDate,
            status: 'pending',
            estimatedCost: (template.estimatedCostMin + template.estimatedCostMax) / 2,
            isOptional: template.isOptional,
            durationDays: template.durationDays,
            autoGenerated: true,
            generatedReason: template.reasonEnglish,
            generatedReasonTamil: template.reasonTamil
          };
          
          generatedActivities.push(activity);
        }
      }
      
      // Sort by scheduled date
      generatedActivities.sort((a, b) => a.scheduledDate - b.scheduledDate);
      
      return generatedActivities;
      
    } catch (error) {
      console.error('Error generating activity plan:', error);
      throw new Error('Failed to generate activity plan');
    }
  }
  
  /**
   * Convert frequency to days
   */
  getFrequencyInDays(frequency) {
    const map = {
      daily: 1,
      weekly: 7,
      biweekly: 14,
      monthly: 30
    };
    return map[frequency] || 0;
  }
  
  /**
   * Check for scheduling conflicts
   * @param {Object} plan - FarmingPlan document
   * @param {Object} newActivity - Activity to check
   * @returns {Object} - Conflict details or null
   */
  async checkConflicts(plan, newActivity) {
    try {
      const newDate = new Date(newActivity.scheduledDate);
      const conflicts = [];
      
      // Check for overlapping activities
      for (const existingActivity of plan.activities) {
        if (existingActivity.status === 'skipped') continue;
        
        const existingDate = new Date(existingActivity.scheduledDate);
        const daysDiff = Math.abs((newDate - existingDate) / (1000 * 60 * 60 * 24));
        
        // Activities on same day
        if (daysDiff < 1) {
          conflicts.push({
            conflictType: 'overlap',
            activity: existingActivity,
            descriptionEnglish: `${newActivity.activityType} and ${existingActivity.activityType} are scheduled on the same day`,
            descriptionTamil: `${newActivity.activityType} மற்றும் ${existingActivity.activityType} ஒரே நாளில் திட்டமிடப்பட்டுள்ளன`
          });
        }
      }
      
      // Check for impossible sequences
      const impossibleSequences = this.getImpossibleSequences();
      for (const existing of plan.activities) {
        const key = `${newActivity.activityType}_before_${existing.activityType}`;
        if (impossibleSequences[key] && newDate < new Date(existing.scheduledDate)) {
          conflicts.push({
            conflictType: 'impossible_sequence',
            activity: existing,
            descriptionEnglish: `Cannot do ${newActivity.activityType} before ${existing.activityType}`,
            descriptionTamil: `${existing.activityType} செய்வதற்கு முன் ${newActivity.activityType} செய்ய முடியாது`
          });
        }
      }
      
      // Save conflicts to database
      if (conflicts.length > 0) {
        for (const conflict of conflicts) {
          await ActivityConflict.create({
            planId: plan._id,
            activity1: {
              activityType: newActivity.activityType,
              scheduledDate: newActivity.scheduledDate
            },
            activity2: {
              activityId: conflict.activity._id,
              activityType: conflict.activity.activityType,
              scheduledDate: conflict.activity.scheduledDate
            },
            conflictType: conflict.conflictType,
            descriptionEnglish: conflict.descriptionEnglish,
            descriptionTamil: conflict.descriptionTamil,
            resolution: this.suggestResolution(plan, newActivity, conflict)
          });
        }
        
        return {
          hasConflicts: true,
          conflicts: conflicts,
          suggestedDate: this.findNextAvailableDate(plan, newActivity)
        };
      }
      
      return { hasConflicts: false };
      
    } catch (error) {
      console.error('Error checking conflicts:', error);
      throw error;
    }
  }
  
  /**
   * Define impossible activity sequences
   */
  getImpossibleSequences() {
    return {
      'harvesting_before_seed_sowing': true,
      'seed_sowing_before_land_preparation': true,
      'seed_sowing_before_ploughing': true
    };
  }
  
  /**
   * Suggest resolution for conflict
   */
  suggestResolution(plan, newActivity, conflict) {
    const suggestedDate = this.findNextAvailableDate(plan, newActivity);
    
    return {
      suggestedDate: suggestedDate,
      reasonEnglish: `Rescheduled to avoid conflict with ${conflict.activity.activityType}`,
      reasonTamil: `${conflict.activity.activityType} உடன் முரண்பாட்டைத் தவிர்க்க மாற்றி அமைக்கப்பட்டது`
    };
  }
  
  /**
   * Find next available date without conflicts
   */
  findNextAvailableDate(plan, newActivity) {
    const startDate = new Date(newActivity.scheduledDate);
    let candidateDate = new Date(startDate);
    candidateDate.setDate(candidateDate.getDate() + 1);
    
    let attempts = 0;
    const maxAttempts = 30; // Check up to 30 days ahead
    
    while (attempts < maxAttempts) {
      let hasConflict = false;
      
      for (const activity of plan.activities) {
        const activityDate = new Date(activity.scheduledDate);
        if (this.isSameDay(candidateDate, activityDate)) {
          hasConflict = true;
          break;
        }
      }
      
      if (!hasConflict) {
        return candidateDate;
      }
      
      candidateDate.setDate(candidateDate.getDate() + 1);
      attempts++;
    }
    
    return candidateDate;
  }
  
  /**
   * Check if two dates are the same day
   */
  isSameDay(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() &&
           date1.getMonth() === date2.getMonth() &&
           date1.getDate() === date2.getDate();
  }
  
  /**
   * Validate activity reschedule
   */
  async validateReschedule(plan, activityId, newDate, reason) {
    try {
      const activity = plan.activities.id(activityId);
      if (!activity) {
        throw new Error('Activity not found');
      }
      
      // Create temporary activity object for conflict check
      const tempActivity = {
        ...activity.toObject(),
        scheduledDate: newDate
      };
      
      // Check conflicts with new date
      const conflictCheck = await this.checkConflicts(plan, tempActivity);
      
      return {
        valid: !conflictCheck.hasConflicts,
        conflicts: conflictCheck.conflicts || [],
        suggestedDate: conflictCheck.suggestedDate,
        reason: reason
      };
      
    } catch (error) {
      console.error('Error validating reschedule:', error);
      throw error;
    }
  }
}

export default new ActivityPlanningService();
